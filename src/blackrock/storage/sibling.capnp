# Sandstorm Blackrock
# Copyright (c) 2015 Sandstorm Development Group, Inc.
# All Rights Reserved

@0xce14f1ce85b2c651;

$import "/capnp/c++.capnp".namespace("blackrock::storage");
using Storage = import "/blackrock/storage.capnp";
using FsStorage = import "/blackrock/fs-storage.capnp";
using ObjectId = FsStorage.StoredObjectId;
using ObjectKey = FsStorage.StoredObjectKey;
using OwnedStorage = Storage.OwnedStorage;

interface Sibling {
  # Interface which storage nodes use to talk to each other.

  createObject @0 (key :ObjectKey) -> (factory :Storage.StorageFactory);
  # Create a new object with the given key -- presumably newly-generated by the caller. The
  # returned factory is good for exactly one call, which will create an object with the desired
  # key.

  getReplica @1 (id :ObjectId) -> (replica :Replica);
  # Get the replica of the given object maintained by this node. Not valid to call if this node is
  # not a member of the object's replica set.
}

interface Replica {
  # A replica of a particular object. Each object has N replicas, where N is a system configuration
  # option that can be adjusted according to the reliability of the underlying storage. The
  # replicas of an object are assigned to storage machines based on a pure function of the
  # object ID.

  getObject @0 (key :ObjectKey) -> GetObjectResults;
  # Open an object for which this sibling is expected to be the leader.

  struct GetObjectResults {
    cap @0 :OwnedStorage;
  }

  # ----------------------------------------------------------------------------
  # Distributed transactions
  #
  # These methods are used to schedule transactions that affect multiple objects, therefore cannot
  # be synchronized by a single leader.

  startTransaction @1 () -> (builder :TransactionBuilder);
  # Starts a transaction on the object. Throws "disconnected" if there is another transaction
  # already occurring.

  cleanupTransaction @2 (id :TransactionId, aborted :Bool);
  # Requests that the callee please complete the given transaction if it is still staged. This is
  # used only when StagedTransaction.commit() or .abort() failed to return successfully. On
  # successfully returning from this call, the callee makes the same guarantee as if commit() or
  # abort() had successfully completed: that it will never call getTransactionState() for this
  # transaction. Note that if the callee knows nothing about the transaction, it should immediately
  # return success on the assumption that the transaction was already completed and cleaned up.

  getTransactionState @3 (id :UInt64) -> (aborted :Bool);
  # Get the state of a transaction for which the callee is the coordinator. If the named
  # transaction is still staged but neither committed nor aborted, waits for it to reach either
  # the commit or the abort state.
  #
  # This call travels in the opposite direction of stageTransaction() and cleanup() and is only
  # used to recover in the case of a crash / partition.

  # ----------------------------------------------------------------------------
  # Leadership
  #
  # Among the replicas of an object, one must be chosen as the "leader" in order for changes
  # to be made.

  getLeaderStatus @4 (key :ObjectKey) -> (version :UInt64, isLeading :Bool);
  # Called by one of the replicas of the given object when it needs to open the object but does
  # not know who the current leader is.
  #
  # The caller must wait for a quorum to respond before proceeding. If no quorum responds, then
  # the caller must either wait forever or throw an exception. Once a quorum responds:
  #
  # - If any replica claims to be a leader, but its `version` was less than that of any other
  #   replica in the quorum, then the caller calls that replica's abdicate() method, ending its
  #   leadership, and then continues as if that replica had not claimed to be leading.
  #
  # - If none claim to be the leader, then the caller selects the replica with the highest version
  #   (preferring itself) to become the leader, calling its lead() method.
  #
  # - If exactly one replica (of those with the highest version) claims to be leader, then this
  #   replica begins following it, calling its lead() method.
  #
  # - If multiple replicas claim to be leader, then the caller chooses the one with the lowest
  #   replica number and calls lead() on it while calling abdicate() on the other.

  lead @5 (key :ObjectKey) -> GetObjectResults;
  # Tells the target replica to become leader.
  #
  # If the callee was already a follower, it disconnects from that follower role, as if it had
  # crashed and restarted.

  abdicate @6 ();
  # Tells the target replica that it is not the leader and should immediately cease pretending to
  # be. No effect if the callee doesn't think it is the leader.

  follow @7 (leader :Leader) -> (follower :Follower, version :UInt64,
                                 maybeStaged :RawTransaction);
  # Tells the callee to begin following the caller.
  #
  # The returned `version` indicates the follower's object version as of the last committed
  # transaction it saw. The leader must start by replaying any later transactions to catch the
  # follower up. If the follower's version is somehow newer than the leader's, then the leader
  # must immediately abdicate leadership.
  #
  # `maybeStaged`, if not null, is a transaction which had been staged on this replica previously
  # but neither committed nor aborted. Since a transaction is considered ready for commit as soon
  # as a quorum of replicas have staged it, and since a new leader only needs a quorum of followers
  # to start leading, it is guaranteed that every staged transaction will be available to the new
  # leader, although it could be that a staged transaction is only returned by a single follower.
  # In any case, the new leader must consider each of these transactions and look for proof that
  # it was either committed or aborted.
}

interface Leader {
  # Interface exposed by leaders to followers.

  getObject @0 (key :ObjectKey) -> Replica.GetObjectResults;
}

interface Follower {
  # Interface that an object leader uses to broadcast transactions to replicas. A `Replica`
  # is associated with a specific object, not a machine.

  stage @0 (txn :RawTransaction, version :UInt64) -> (staged :StagedTransaction);
  # Stage a transaction. Upon committing this transaction, the object will reach the given version.
  #
  # A quorum of replicas must respond successfully to this call before the transaction can be
  # safely committed. Otherwise, it's possible that the caller is no longer leader, therefore
  # lacks the authority to commit transactions. Therefore, if this transaction is being replicated
  # as part of a stageTransaction() call, that call cannot return success until a quorum of
  # followers have staged the transaction.

  free @1 (id :UInt64);
  # Indicates that all transactions through the given one have been committed by all replicas and
  # therefore can now be deleted from the transaction log.
}

interface TransactionBuilder {
  getTransactional @0 [T] (object :T) -> (transactionalObject :T);
  # Get a transactional wrapper around the given object. `object` must be a capability representing
  # one of the facets of the storage object with which this Transaction is associated. For exmaple,
  # when transacting on an Assingable, `object` may be a capability to the `Assignable` itself or
  # to an `Assignable.Setter` pointing to the same underlying object.
  #
  # Once either `stage()` is called or the `Transaction` is dropped, `transactionalObject` will be
  # revoked.

  addOps @1 (ops :List(RawTransaction.Op));
  # Add some direct low-level ops.

  stage @2 (id :TransactionId) -> (staged :StagedTransaction);
  # Prepare to commit the transaction. If this succeeds, then the underlying object has been
  # locked. All other transactions will be rejected until this transaction is either committed or
  # aborted.
}

interface StagedTransaction {
  # A transaction that has been staged and is ready to commit. While the transaction is staged,
  # no conflicting transactions are allowed to be created, thus ensuring that the transaction
  # can be committed whenever the coordinator is ready.
  #
  # If a StagedTransaction becomes disconnected without commit() or abort() successfully being
  # called, then the callee will need to independently determine whether the commit or abort
  # condition was reached by contacting other nodes. This is an ususual case -- normally, either
  # commit() or abort() is called and the callee is absolved of the need to verify.
  #
  # Once commit() or abort() returns successfully, the callee guarantees that it will not under
  # any circumstances call back to ask the transaction's status, therefore the caller can
  # potentially clean up any information it was keeping about the transaction. If these methods
  # throw an exception instead (especially "disconnected") then the caller will need to keep state
  # so that it can respond to such callbacks. It may periodically inquire as to whether it is safe
  # to throw away said state.

  commit @0 ();
  # Asserts that the transaction's commit condition has been reached. The callee need not
  # independently verify.

  abort @1 ();
  # Asserts that the transaction's abort condition has been reached. The callee need not
  # independently verify.
}

struct TransactionId {
  coordinator @0 :ObjectId;
  # Identities the "lead object" of this transaction. The storage nodes responsible for tracking
  # this object are also responsible for deciding when the transaction has completed.

  id @1 :UInt64;
  # The ID of this transaction among those associated with the coordinator object. Note that an
  # ID can be reused so long as the old ID has been globally forgotten.
}

struct RawTransaction {
  id @0 :TransactionId;

  version @1 :UInt64;
  # Version we'll transition to if this transaction goes through.

  ops @2 :List(Op);

  struct Op {
    union {
      create @0 :UInt8;
      # Type is ObjectType enum from basics.h.

      setContent @1 :Data;

      delete @2 :Void;

      becomeReadOnly @3 :Void;

      setAccountedBlockCount @4 :UInt32;

      setTransitiveBlockCount @5 :UInt64;

      setParent @6 :ObjectId;

      backburnerModifyTransitiveBlockCount @7 :Int64;
      # Schedules a backburner task to eventually modify this object's transitive block count and
      # recurse to its parent. The value is applied as a delta.

      backburnerRecursivelyDelete @8 :Void;

      removeBackburner @9 :UInt64;
      # Remove all backburners that had been scheduled at the given version.
    }
  }
}

struct StorageConfig {
  replicasPerObject @0 :UInt8;
  # Number of replicas of each object.

  quorumSize @1 :UInt8;
  # How many votes does it take to elect a leader?
  #
  # This need not be strictly "half the replicas plus one". When a leader broadcasts a transaction
  # to followers, it needs some number of followers N to acknowledge the transaction before the
  # object leader can signal acceptance to the transaction coordinator. This N is the minimum
  # number such than N + quorumSize > replicasPerObject.
  #
  # In particular this means that when quorumSize == replicasPerObject, then the leader can
  # immediately accept a transaction without consulting any followers. However, it means that if
  # any machine in the replica set is unreachable then no writes will be allowed at all until
  # the machine comes back up. (And the permanent loss of one replica's storage could mean data
  # loss.)
}
